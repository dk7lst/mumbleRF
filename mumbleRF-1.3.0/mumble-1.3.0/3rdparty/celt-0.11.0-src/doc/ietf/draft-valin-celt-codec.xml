<?xml version='1.0'?>
<!DOCTYPE rfc SYSTEM 'rfc2629.dtd'>
<?rfc toc="yes" symrefs="yes" ?>

<rfc ipr="trust200902" category="std" docName="draft-valin-celt-codec-02">

<front>
<title abbrev="CELT codec">Constrained-Energy Lapped Transform (CELT) Codec</title>



<author initials="J-M" surname="Valin" fullname="Jean-Marc Valin">
<organization>Octasic Semiconductor</organization>
<address>
<postal>
<street>4101, Molson Street, suite 300</street>
<city>Montreal</city>
<region>Quebec</region>
<code>H1Y 3L1</code>
<country>Canada</country>
</postal>
<email>jean-marc.valin@octasic.com</email>
</address>
</author>

<author initials="T" surname="Terriberry" fullname="Timothy B. Terriberry">
<organization>Xiph.Org Foundation</organization>
<address>
<postal>
<street></street>
<city></city>
<region></region>
<code></code>
<country></country>
</postal>
<email>tterribe@xiph.org</email>
</address>
</author>

<author initials="G" surname="Maxwell" fullname="Gregory Maxwell">
<organization>Juniper Networks</organization>
<address>
<postal>
<street>2251 Corporate Park Drive, Suite 100</street>
<city>Herndon</city>
<region>VA</region>
<code>20171-1817</code>
<country>USA</country>
</postal>
<email>gmaxwell@juniper.net</email>
</address>
</author>

<author initials="C" surname="Montgomery" fullname="Christopher Montgomery">
<organization>Xiph.Org Foundation</organization>
<address>
<postal>
<street></street>
<city></city>
<region></region>
<code></code>
<country></country>
</postal>
<email>xiphmont@xiph.org</email>
</address>
</author>

<date day="8" month="July" year="2010" />

<area>General</area>

<workgroup>AVT Working Group</workgroup>
<keyword>audio codec</keyword>
<keyword>low delay</keyword>
<keyword>Internet-Draft</keyword>
<keyword>CELT</keyword>

<abstract>
<t>
CELT <xref target="celt-website"/> is an open-source voice codec suitable for use in very low delay 
Voice over IP (VoIP) type applications.  This document describes the encoding
and decoding process. 
</t>
</abstract>
</front>

<middle>

<section anchor="Introduction" title="Introduction">
<t>
This document describes the CELT codec, which is designed for transmitting full-bandwidth
audio with very low delay. It is suitable for encoding both
speech and music at rates starting at 32 kbit/s. It is primarily designed for transmission
over the Internet and protocols such as RTP <xref target="rfc3550"/>, but also includes
a certain amount of robustness to bit errors, where this could be done at no significant
cost. 
</t>

<t>The novel aspect of CELT compared to most other codecs is its very low delay,
below 10 ms. There are two main advantages to having a very low delay audio link.
The lower delay itself is important for some interactions, such as playing music
remotely. Another advantage is its behavior in the presence of acoustic echo. When
the round-trip audio delay is sufficiently low, acoustic echo is no longer
perceived as a distinct repetition, but rather as extra reverberation. Applications
of CELT include:</t>
<t>
<list style="symbols">
<t>Collaborative network music performance</t>
<t>High-quality teleconferencing</t>
<t>Wireless audio equipment</t>
<t>Low-delay links for broadcast applications</t>
</list>
</t>

<t>The source code for the reference implementation of the CELT codec is provided in <xref target="ref-implementation"/>. This source code is the normative specification
of the codec. The corresponding text description in this document is provided
for informative purposes. </t>

<t>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in RFC 2119 <xref target="rfc2119"/>.
</t>

</section>

<section anchor="overview" title="Overview of the CELT Codec">

<t>
CELT stands for <spanx style="emph">Constrained Energy Lapped Transform</spanx>. This is
the fundamental principle of the codec: the quantization process is designed in such a way
as to preserve the energy in a certain number of bands. The theoretical aspects of the
codec are described in greater detail <xref target="celt-tasl"/> and 
<xref target="celt-eusipco"/>. Although these papers describe slightly older versions of
the codec (version 0.3.2 and 0.5.1, respectively), the principles remain the same.
</t>

<t>CELT is a transform codec, based on the Modified Discrete Cosine Transform 
(MDCT). The MDCT is derived from the DCT-IV by adding an overlap with time-domain
aliasing cancellation <xref target="mdct"/>.
The main characteristics of CELT are as follows:

<list style="symbols">
<t>Ultra-low algorithmic delay (scalable, typically 4 to 9 ms)</t>
<t>Sampling rates from 32 kHz to 48 kHz and above (full audio bandwidth)</t>
<t>Applicability to both speech and music</t>
<t>Support for mono and stereo</t>
<t>Adaptive bit-rate from 32 kbit/s to 128 kbit/s per channel and above</t>
<t>Scalable complexity</t>
<t>Robustness to packet loss (scalable trade-off between quality and loss-robustness)</t>
<t>Open source implementation (floating-point and fixed-point)</t>
<t>No known intellectual property issues</t>
</list>
</t>

<section anchor="bitstream" title="Bit-stream definition">

<t>
This document contains a detailed description of both the encoder and the decoder, along with a reference implementation. In most circumstances, and unless otherwise stated, the calculations
do <spanx style="strong">not</spanx> need to produce results that are bit-identical with the reference implementation, so alternate algorithms can sometimes be used. However, there are a few (clearly identified) cases, such as the bit allocation, where bit-exactness with the reference
implementation is required. An implementation is considered to be compatible if, for any valid bit-stream, the decoder's output is perceptually indistinguishable from the output produced by the reference decoder.
</t>

<t>
The CELT codec does not use a standard <spanx style="emph">bit-packer</spanx>, 
but rather uses a range coder to pack both integers and entropy-coded symbols. 
In mono mode, the bit-stream generated by the encoder contains the 
following parameters (in order):
</t>

<t>
<list style="symbols">
<t>Feature flags I, P, S, F (2-4 bits)</t>
<t>if P=1
   <list style="symbols">
      <t>Pitch period</t>
   </list></t>
<t>if S=1
   <list style="symbols">
      <t>Transient scalefactor</t>
      <t>if scalefactor=(1 or 2) AND more than 2 short MDCTs
	     <list style="symbols">
		    <t>ID of block before transient</t>
		 </list></t>
      <t>if scalefactor=3
	     <list style="symbols">
		    <t>Transient time</t>
      </list></t>
   </list></t>
<t>Coarse energy encoding (for each band)</t>
<t>Fine energy encoding (for each band)</t>
<t>For each band
   <list style="symbols">
      <t>if P=1 and band is at the beginning of a pitch band
	  <list>
	     <t>Pitch gain bit</t>
	  </list></t>
	  <t>PVQ indices</t>
   </list></t>
<t>More fine energy (using all remaining bits)</t>
</list>
</t>

<t>Note that due to the use of a range coder, all of the parameters have to be encoded and decoded in order. </t>

<t>
The CELT bit-stream is "octet-based" in the sense that the encoder always produces an 
integer number of octets when encoding a frame. Also, the bit-rate used by the CELT encoder can 
<spanx style="strong">only</spanx> be determined by the number of octets produced.
In many cases (e.g. UDP/RTP), the transport layer already encodes the data length, so
no extra information is necessary to signal the bit-rate. In cases where this is not true,
or when there are multiple compressed frames per packet, the size of each compressed
frame MUST be signalled in some way.
</t>


</section>

</section>

<section anchor="CELT Modes" title="CELT Modes">
<t>
The operation of both the encoder and decoder depends on the mode data. A mode
definition can be created by celt_create_mode() (<xref target="modes.c">modes.c</xref>)
based on three parameters:
<list style="symbols">
<t>frame size (number of samples)</t>
<t>sampling rate (samples per second)</t>
<t>number of channels (1 or 2)</t>
</list>
</t>

<t>The frame size can be any even number of samples from 64 to 1024, inclusively. 
The sampling rate must be between 32000 Hz and 96000 Hz. The mode data that is 
created defines how the encoder and the decoder operate. More specifically, the
following information is contained in the mode object:

<list style="symbols">
<t>Frame size</t>
<t>Sampling rate</t>
<t>Windowing overlap</t>
<t>Number of channels</t>
<t>Definition of the bands</t>
<t>Definition of the <spanx style="emph">pitch bands</spanx></t>
<t>Decay coefficients of the Laplace distributions for coarse energy</t>
<t>Bit allocation matrix</t>
</list>
</t>

<t>
The windowing overlap is the amount of overlap between the frames. CELT uses a low-overlap window that is typically half of the frame size. For a frame size of 256 samples, the overlap is 128 samples, so the total algorithmic delay is 256+128=384. CELT divides the audio into frequency bands, for which the energy is preserved. These bands are chosen to follow the ear's critical bands, with the exception that each band has to contain at least 3 frequency bins. 
</t>

<t>
The energy bands are based on the Bark scale. The Bark band edges (in Hz) are defined as 
[0, 100, 200, 300, 400, 510, 630, 770, 920, 1080, 1270,  1480,  1720,  2000,  2320,
2700, 3150, 3700, 4400, 5300, 6400,  7700, 9500, 12000, 15500, 20000]. The actual bands used by the codec
depend on the sampling rate and the frame size being used. The mapping from Hz to MDCT bins is done by
multiplying by sampling_rate/(2*frame_size) and rounding to the nearest value. An exception is made for
the lower frequencies to ensure that all bands contain at least 3 MDCT bins. The definition of the Bark
bands is computed in compute_ebands() (<xref target="modes.c">modes.c</xref>).
</t>

<t>
CELT includes a pitch predictor for which the gains are defined over 
a set of <spanx style="emph">pitch bands</spanx>. The pitch bands are defined
(in Hz) as [0, 345, 689, 1034, 1378, 2067, 3273, 5340, 6374]. The Hz values
are mapped to MDCT bins in the same was as the energy bands. The pitch
band boundaries are aligned to energy band boundaries. The definition of the pitch
bands is computed in compute_pbands() (<xref target="modes.c">modes.c</xref>).
</t>

<t>
The mode contains a bit allocation table that is derived from a prototype allocation table,
specified in the band_allocation matrix (<xref
target="modes.c">modes.c</xref>). Each row of the table is a single prototype allocation,
in bits per Bark band, and assuming 256-sample frames. These rows must be projected onto the actual band layout in use at the
current frame size and sample rate, using exact integer calculations. The reference
implementation
pre-computes these projections in compute_allocation_table() (<xref
target="modes.c">modes.c</xref>) and any other implementation
MUST produces bit-identical allocation results.
</t>

<t>
Every entry in the allocation table is multiplied by the current number of channels and
the current frame size. Each prototype allocation is projected
independently using the following process: the upper band frequencies (in Hz) from the current Bark band and current CELT band are compared. (When the process begins, these will each be the first band, but will increment independently.) If the current Bark band's upper edge frequency 
is less than the current CELT band's upper edge frequency, the entire value of the Bark band plus any carried remainder is assigned to the current CELT
band, and the process continues with the next
Bark band in sequence and zero remainder. If the current Bark band's upper edge frequency is equal to or greater than that of
the current CELT band, the CELT band will receive only part of this Bark band's allocation.
This portion allocated to the CELT band is then calculated by multiplying the Bark band's allocation by the
difference in Hz between the Bark band's upper frequency and the current
CELT band's lower frequency, adding the width of the current Bark band
divided by two, and then dividing this total by the width of the current Bark
band in Hz. The partial value plus any carried remainder is added to the current
CELT band, and the difference between the partial value and the Bark target is
taken as the new carried remainder. The process begins then again starting at the
next CELT band and next Bark band. Once all bands in a prototype allocation have been considered, any
remainder is added to the last CELT band. All of the resulting values are
rescaled by adding 128 and dividing by 256.
</t>

</section>

<section anchor="CELT Encoder" title="CELT Encoder">

<t>
The top-level function for encoding a CELT frame in the reference implementation is
celt_encode() (<xref target="celt.c">celt.c</xref>).
The basic block diagram of the CELT encoder is illustrated in <xref target="encoder-diagram"></xref>.
The encoder contains most of the building blocks of the decoder and can,
with very little extra computation, compute the signal that would be decoded by the decoder.
CELT has three main quantizers denoted Q1, Q2 and Q3. These apply to band energies 
(<xref target="energy-quantization"></xref>), pitch gains (<xref target="pitch-prediction"></xref>)
and normalized MDCT bins (<xref target="pvq"></xref>), respectively.
</t>

<figure anchor="encoder-diagram">
<artwork>
<![CDATA[
                  +-----------+        +--+
               +--|  Energy   |-+----->|Q1|------+
               |  |computation| |      +--+      |
               |  +-----------+ |                |
               |          +-----+                |
               |          v                      v
  +------+  +-+--+  +-+  +-+  +-+  +--+  +---+  +-+  +-----+  +-+
->|Window|->|MDCT|->|-|->|/|->|-|->|Q3|->|Mix|->|*|->|IMDCT|->|+|-+->
  +---+--+  +----+  +-+  +-+  +-+  +--+  +---+  +-+  +-----+  +-+ |
       |             ^                                            |
       |             +--------------------------+                 |
       +-+                                      |                 |
         |              +----------+   +--+   +-+-+               |
         +------------->|pitch gain|-->|Q2|-->| * |               |
         |              +----------+   +--+   +---+               |
         |                    ^                 ^                 |
         |                    +-----------------+                 |
         v                                      |                 |
   +------------+                        +------+-----+           |
   |Pitch period|                        |Delay, MDCT,|           |
   |estimation  |----------------------->|  Normalize |           |
   +------------+                        +------------+           |
         ^                                      ^                 |
         +--------------------------------------+-----------------+
]]>
</artwork>
<postamble>Block diagram of the CELT encoder</postamble>
</figure>


<t>The input audio first goes through a pre-emphasis filter 
(just before the windowing in <xref target="encoder-diagram"></xref>), which attenuates the
<spanx style="emph">spectral tilt</spanx>. The filter is has the transfer function A(z)=1-alpha_p*z^-1, with
alpha_p=0.8. The inverse of the pre-emphasis is applied at the decoder.</t>


<section anchor="range-encoder" title="Range Coder">
<t>
CELT uses an entropy coder based upon <xref target="range-coding"></xref>, 
which is itself a rediscovery of the FIFO arithmetic code introduced by <xref target="coding-thesis"></xref>.
It is very similar to arithmetic encoding, except that encoding is done with
digits in any base instead of with bits, 
so it is faster when using larger bases (i.e.: an octet). All of the
calculations in the range coder must use bit-exact integer arithmetic.
</t>

<t>
The range coder also acts as the bit-packer for CELT. It is
used in three different ways, to encode:
<list style="symbols">
<t>entropy-coded symbols with a fixed probability model using ec_encode(), (<xref target="rangeenc.c">rangeenc.c</xref>)</t>
<t>integers from 0 to 2^M-1 using ec_enc_uint() or ec_enc_bits(), (<xref target="entenc.c">entenc.c</xref>)</t>
<t>integers from 0 to N-1 (where N is not a power of two) using ec_enc_uint(). (<xref target="entenc.c">entenc.c</xref>)</t>
</list>
</t>

<t>
The range encoder maintains an internal state vector composed of the
four-tuple (low,rng,rem,ext), representing the low end of the current
range, the size of the current range, a single buffered output octet,
and a count of additional carry-propagating output octets. Both rng
and low are 32-bit unsigned integer values, rem is an octet value or
the special value -1, and ext is an integer with at least 16 bits.
This state vector is initialized at the start of each each frame to
the value (0,2^31,-1,0).
</t>

<t>
Each symbol is drawn from a finite alphabet and coded in a separate
context which describes the size of the alphabet and the relative
frequency of each symbol in that alphabet. CELT only uses static
contexts; they are not adapted to the statistics of the data that is
coded.
</t>

<section anchor="encoding-symbols" title="Encoding Symbols">
<t>
   The main encoding function is ec_encode() (<xref target="rangeenc.c">rangeenc.c</xref>),
   which takes as an argument a three-tuple (fl,fh,ft)
   describing the range of the symbol to be encoded in the current
   context, with 0 &lt;= fl &lt; fh &lt;= ft &lt;= 65535. The values of this tuple
   are derived from the probability model for the symbol. Let f(i) be
   the frequency of the ith symbol in the current context. Then the
   three-tuple corresponding to the kth symbol is given by
   <![CDATA[
fl=sum(f(i),i<k), fh=fl+f(i), and ft=sum(f(i)).
]]>
</t>
<t>
   ec_encode() updates the state of the encoder as follows. If fl is
   greater than zero, then low = low + rng - (rng/ft)*(ft-fl) and 
   rng = (rng/ft)*(fh-fl). Otherwise, low is unchanged and
   rng = rng - (rng/ft)*(fh-fl). The divisions here are exact integer
   division. After this update, the range is normalized.
</t>
<t>
   To normalize the range, the following process is repeated until
   rng > 2^23. First, the top 9 bits of low, (low>>23), are placed into
   a carry buffer. Then, low is set to <![CDATA[(low << 8 & 0x7FFFFFFF) and rng
   is set to (rng<<8)]]>. This process is carried out by
   ec_enc_normalize() (<xref target="rangeenc.c">rangeenc.c</xref>).
</t>
<t>
   The 9 bits produced in each iteration of the normalization loop
   consist of 8 data bits and a carry flag. The final value of the
   output bits is not determined until carry propagation is accounted
   for. Therefore the reference implementation buffers a single
   (non-propagating) output octet and keeps a count of additional
   propagating (0xFF) output octets. An implementation MAY choose to use
   any mathematically equivalent scheme to perform carry propagation.
</t>
<t>
   The function ec_enc_carry_out() (<xref target="rangeenc.c">rangeenc.c</xref>) performs
   this buffering. It takes a 9-bit input value, c, from the normalization
   8-bit output and a carry bit. If c is 0xFF, then ext is incremented
   and no octets are output. Otherwise, if rem is not the special value
   -1, then the octet (rem+(c>>8)) is output. Then ext octets are output
   with the value 0 if the carry bit is set, or 0xFF if it is not, and
   rem is set to the lower 8 bits of c. After this, ext is set to zero.
</t>
<t>
   In the reference implementation, a special version of ec_encode()
   called ec_encode_bin() (<xref target="rangeenc.c">rangeenc.c</xref>) is defined to
   take a two-tuple (fl,ftb), where <![CDATA[0 <= fl < 2^ftb and ftb < 16. It is
   mathematically equivalent to calling ec_encode() with the three-tuple
   (fl,fl+1,1<<ftb)]]>, but avoids using division.

</t>
</section>

<section anchor="encoding-ints" title="Encoding Uniformly Distributed Integers">
<t>
   Functions ec_enc_uint() or ec_enc_bits() are based on ec_encode() and 
   encode one of N equiprobable symbols, each with a frequency of 1,
   where N may be as large as 2^32-1. Because ec_encode() is limited to
   a total frequency of 2^16-1, this is done by encoding a series of
   symbols in smaller contexts.
</t>
<t>
   ec_enc_bits() (<xref target="entenc.c">entenc.c</xref>) is defined, like
   ec_encode_bin(), to take a two-tuple (fl,ftb), with <![CDATA[0 <= fl < 2^ftb
   and ftb < 32. While ftb is greater than 8, it encodes bits (ftb-8) to
   (ftb-1) of fl, e.g., (fl>>ftb-8&0xFF) using ec_encode_bin() and
   subtracts 8 from ftb. Then, it encodes the remaining bits of fl, e.g.,
   (fl&(1<<ftb)-1)]]>, again using ec_encode_bin().
</t>
<t>
   ec_enc_uint() (<xref target="entenc.c">entenc.c</xref>) takes a two-tuple (fl,ft),
   where ft is not necessarily a power of two. Let ftb be the location
   of the highest 1 bit in the two's-complement representation of
   (ft-1), or -1 if no bits are set. If ftb>8, then the top 8 bits of fl
   are encoded using ec_encode() with the three-tuple
   (fl>>ftb-8,(fl>>ftb-8)+1,(ft-1>>ftb-8)+1), and the remaining bits
   are encoded with ec_enc_bits using the two-tuple
   <![CDATA[(fl&(1<<ftb-8)-1,ftb-8). Otherwise, fl is encoded with ec_encode()
   directly using the three-tuple (fl,fl+1,ft)]]>.
</t>
</section>

<section anchor="encoder-finalizing" title="Finalizing the Stream">
<t>
   After all symbols are encoded, the stream must be finalized by
   outputting a value inside the current range. Let end be the integer
   in the interval [low,low+rng) with the largest number of trailing
   zero bits. Then while end is not zero, the top 9 bits of end, e.g.,
   <![CDATA[(end>>23), are sent to the carry buffer, and end is replaced by
   (end<<8&0x7FFFFFFF). Finally, if the value in carry buffer, rem, is]]>
   neither zero nor the special value -1, or the carry count, ext, is
   greater than zero, then 9 zero bits are sent to the carry buffer.
   After the carry buffer is finished outputting octets, the rest of the
   output buffer is padded with zero octets. Finally, rem is set to the
   special value -1. This process is implemented by ec_enc_done()
   (<xref target="rangeenc.c">rangeenc.c</xref>).
</t>
</section>

<section anchor="encoder-tell" title="Current Bit Usage">
<t>
   The bit allocation routines in CELT need to be able to determine a
   conservative upper bound on the number of bits that have been used
   to encode the current frame thus far. This drives allocation
   decisions and ensures that the range code will not overflow the
   output buffer. This is computed in the reference implementation to
   fractional bit precision by the function ec_enc_tell() 
   (<xref target="rangeenc.c">rangeenc.c</xref>).
   Like all operations in the range encoder, it must
   be implemented in a bit-exact manner.
</t>
</section>

</section>

<section anchor="Encoder Feature Selection" title="Encoder Feature Selection">

<t>
The CELT codec has several optional features that can be switched on or off in each frame, some of which are mutually exclusive. The four main flags are intra-frame energy (I), pitch (P), short blocks (S), and folding (F). Those are described in more detail below. There are eight valid combinations of these four features, and they are encoded into the stream first using a variable length code (<xref target="flags-encoding"></xref>). It is left to the implementor to choose when to enable each of the flags, with the only restriction that the combination of the four flags MUST correspond to a valid entry in <xref target="flags-encoding"></xref>.
</t>

<texttable anchor="flags-encoding">
        <preamble>Encoding of the feature flags</preamble>
        <ttcol align='center'>I</ttcol>
        <ttcol align='center'>P</ttcol>
        <ttcol align='center'>S</ttcol>
        <ttcol align='center'>F</ttcol>
        <ttcol align='right'>Encoding</ttcol>
        <c>0</c><c>0</c><c>0</c><c>1</c><c>00</c>
        <c>0</c><c>1</c><c>0</c><c>1</c><c>01</c>
        <c>1</c><c>0</c><c>0</c><c>1</c><c>110</c>
        <c>1</c><c>0</c><c>1</c><c>1</c><c>111</c>
		
        <c>0</c><c>0</c><c>0</c><c>0</c><c>1000</c>
        <c>0</c><c>0</c><c>1</c><c>1</c><c>1001</c>
        <c>0</c><c>1</c><c>0</c><c>0</c><c>1010</c>
        <c>1</c><c>0</c><c>0</c><c>0</c><c>1011</c>
</texttable>

<section anchor="intra" title="Intra-frame energy (I)">
<t>
CELT uses prediction to encode the energy in each frequency band. In order to make frames independent, however, it is possible to disable the part of the prediction that depends on previous frames. This is called <spanx style="emph">intra-frame energy</spanx> and requires around 12 more bits per frame. It is enabled with the <spanx style="emph">I</spanx> bit (Table. <xref target="flags-encoding">flags-encoding</xref>). The use of intra energy is OPTIONAL and the decision method is left to the implementor. The reference code describes one way of deciding which frames would benefit most from having their energy encoded without prediction. The intra_decision() (<xref target="quant_bands.c">quant_bands.c</xref>) function looks for frames where the log-spectral distance between consecutive frames is more than 9 dB. When such a difference is found between two frames, the next frame (not the one for which the difference is detected) is marked encoded with intra energy. The one-frame delay is to ensure that when a frame containing a transient is lost, then the next frame will be decoded without accumulating error from the lost frame.
</t>
</section>

<section anchor="pitch" title="Pitch prediction (P)">
<t>
CELT can use a pitch predictor (also known as long-term predictor) to improve the voice quality at lower bit-rates. When the <spanx style="emph">P</spanx> bit is set, the pitch period is encoded after the flag bits. The value encoded is an integer in the range [0, 1024-N-overlap-1].
</t>
</section>

<section anchor="short-blocks" title="Short blocks (S)">
<t>
To improve audio quality during transients, CELT can use a <spanx style="emph">short block</spanx> multiple-MDCT transform. Unlike other transform codecs, the multiple MDCTs are jointly quantized as if the coefficients were obtained from a single MDCT. For that reason, it is better to consider the short block case as using a different transform of the same length rather than as multiple independent MDCTs. In the reference implementation, the decision to use short blocks is made by transient_analysis() (<xref target="celt.c">celt.c</xref>) based on the pre-emphasized signal's peak values, but other methods can be used. When the <spanx style="emph">S</spanx> bit is set, a 2-bit transient scalefactor is encoded directly after the flag bits. If the scalefactor is 0, then the multiple-MDCT output is unmodified. If the scalefactor is 1 or 2, then the output of the MDCTs that follow the transient is scaled down by 2^scalefactor. If the scalefactor is equal to 3, then a time-domain pre-emphasis window is applied <spanx style="strong">before</spanx> computing the MDCTs and no further scaling is applied to the MDCTs output. The window value is 1 from the beginning of the frame to 16 samples before the transient time. It is a Hanning window from there to the transient time, and then the value is 1/8 up to the end of the frame. The Hanning window part is defined as:
</t>

<t>
static const float transientWindow[16] = {
   0.0085135, 0.0337639, 0.0748914, 0.1304955, 
   0.1986827, 0.2771308, 0.3631685, 0.4538658,
   0.5461342, 0.6368315, 0.7228692, 0.8013173, 
   0.8695045, 0.9251086, 0.9662361, 0.9914865};
</t>

<t>When the scalefactor is 3, the transient time is the exact time of the transient
determined by the encoder and encoded as an integer number of samples with the range
[0, N+overlap-1] directly after the scalefactor.</t>


<t>
In the case where the scalefactor is 1 or 2 and the mode is defined to use more than 2 MDCTs, the last MDCT to which the scaling is <spanx style="strong">not</spanx> applied is encoded using an integer in the range [0, B-2], where B is the number of short MDCTs used for the mode. 
</t>
</section>

<section anchor="folding" title="Spectral folding (F)">
<t>
The last encoding feature in CELT is spectral folding. It is designed to prevent <spanx style="emph">birdie</spanx> artifacts caused by the sparse spectra often generated by low-bitrate transform codecs. When folding is enabled, a copy of the low-frequency spectrum is added to the higher-frequency bands (above ~6400 Hz). The folding operation is described in more detail in <xref target="pvq"></xref>.
</t>
</section>

</section>

<section anchor="forward-mdct" title="Forward MDCT">

<t>The MDCT implementation has no special characteristics. The
input is a windowed signal (after pre-emphasis) of 2*N samples and the output is N
frequency-domain samples. A <spanx style="emph">low-overlap</spanx> window is used to reduce the algorithmic delay. 
It is derived from a basic (full overlap) window that is the same as the one used in the Vorbis codec: W(n)=[sin(pi/2*sin(pi/2*(n+.5)/L))]^2. The low-overlap window is created by zero-padding the basic window and inserting ones in the middle, such that the resulting window still satisfies power complementarity. The MDCT is computed in mdct_forward() (<xref target="mdct.c">mdct.c</xref>), which includes the windowing operation and a scaling of 2/N.
</t>
</section>

<section anchor="normalization" title="Bands and Normalization">
<t>
The MDCT output is divided into bands that are designed to match the ear's critical bands,
with the exception that each band has to be at least 3 bins wide. For each band, the encoder
computes the energy that will later be encoded. Each band is then normalized by the 
square root of the <spanx style="strong">non-quantized</spanx> energy, such that each band now forms a unit vector X.
The energy and the normalization are computed by compute_band_energies()
and normalise_bands() (<xref target="bands.c">bands.c</xref>), respectively.
</t>
</section>

<section anchor="energy-quantization" title="Energy Envelope Quantization">

<t>
It is important to quantize the energy with sufficient resolution because
any energy quantization error cannot be compensated for at a later
stage. Regardless of the resolution used for encoding the shape of a band,
it is perceptually important to preserve the energy in each band. CELT uses a
coarse-fine strategy for encoding the energy in the base-2 log domain, 
as implemented in <xref target="quant_bands.c">quant_bands.c</xref></t>

<section anchor="coarse-energy" title="Coarse energy quantization">
<t>
The coarse quantization of the energy uses a fixed resolution of
6 dB and is the only place where entropy coding is used.
To minimize the bitrate, prediction is applied both in time (using the previous frame)
and in frequency (using the previous bands). The 2-D z-transform of
the prediction filter is: A(z_l, z_b)=(1-a*z_l^-1)*(1-z_b^-1)/(1-b*z_b^-1)
where b is the band index and l is the frame index. The prediction coefficients are
a=0.8 and b=0.7 when not using intra energy and a=b=0 when using intra energy. 
The time-domain prediction is based on the final fine quantization of the previous
frame, while the frequency domain (within the current frame) prediction is based
on coarse quantization only (because the fine quantization has not been computed
yet). We approximate the ideal 
probability distribution of the prediction error using a Laplace distribution. The
coarse energy quantization is performed by quant_coarse_energy() and 
quant_coarse_energy() (<xref target="quant_bands.c">quant_bands.c</xref>).
</t>

<t>
The Laplace distribution for each band is defined by a 16-bit (Q15) decay parameter.
Thus, the value 0 has a frequency count of p[0]=2*(16384*(16384-decay)/(16384+decay)). The 
values +/- i each have a frequency count p[i] = (p[i-1]*decay)>>14. The value of p[i] is always
rounded down (to avoid exceeding 32768 as the sum of all frequency counts), so it is possible
for the sum to be less than 32768. In that case additional values with a frequency count of 1 are encoded. The signed values corresponding to symbols 0, 1, 2, 3, 4, ... 
are [0, +1, -1, +2, -2, ...]. The encoding of the Laplace-distributed values is 
implemented in ec_laplace_encode() (<xref target="laplace.c">laplace.c</xref>).
</t>
<!-- FIXME: bit budget consideration -->
</section> <!-- coarse energy -->

<section anchor="fine-energy" title="Fine energy quantization">
<t>
After the coarse energy quantization and encoding, the bit allocation is computed 
(<xref target="allocation"></xref>) and the number of bits to use for refining the
energy quantization is determined for each band. Let B_i be the number of fine energy bits 
for band i; the refinement is an integer f in the range [0,2^B_i-1]. The mapping between f
and the correction applied to the coarse energy is equal to (f+1/2)/2^B_i - 1/2. Fine
energy quantization is implemented in quant_fine_energy() 
(<xref target="quant_bands.c">quant_bands.c</xref>).
</t>

<t>
If any bits are unused at the end of the encoding process, these bits are used to
increase the resolution of the fine energy encoding in some bands. Priority is given
to the bands for which the allocation (<xref target="allocation"></xref>) was rounded
down. At the same level of priority, lower bands are encoded first. Refinement bits
are added until there are no unused bits. This is implemented in quant_energy_finalise() 
(<xref target="quant_bands.c">quant_bands.c</xref>).
</t>

</section> <!-- fine energy -->


</section> <!-- Energy quant -->

<section anchor="allocation" title="Bit Allocation">
<t>Bit allocation is performed based only on information available to both
the encoder and decoder. The same calculations are performed in a bit-exact
manner in both the encoder and decoder to ensure that the result is always
exactly the same. Any mismatch would cause an error in the decoded output.
The allocation is computed by compute_allocation() (<xref target="rate.c">rate.c</xref>),
which is used in both the encoder and the decoder.</t>

<t>For a given band, the bit allocation is nearly constant across
frames that use the same number of bits for Q1, yielding a 
pre-defined signal-to-mask ratio (SMR) for each band. Because the
bands each have a width of one Bark, this is equivalent to modeling the
masking occurring within each critical band, while ignoring inter-band
masking and tone-vs-noise characteristics. While this is not an
optimal bit allocation, it provides good results without requiring the
transmission of any allocation information.
</t>


<t>
For every encoded or decoded frame, a target allocation must be computed
using the projected allocation. In the reference implementation this is
performed by compute_allocation() (<xref target="rate.c">rate.c</xref>).
The target computation begins by calculating the available space as the
number of whole bits which can be fit in the frame after Q1 is stored according
to the range coder (ec_[enc/dec]_tell()) and then multiplying by 8.
Then the two projected prototype allocations whose sums multiplied by 8 are nearest
to that value are determined. These two projected prototype allocations are then interpolated
by finding the highest integer interpolation coefficient in the range 0-8
such that the sum of the higher prototype times the coefficient, plus the
sum of the lower prototype multiplied by
the difference of 16 and the coefficient, is less than or equal to the
available sixteenth-bits. 
The reference implementation performs this step using a binary search in
interp_bits2pulses() (<xref target="rate.c">rate.c</xref>). The target  
allocation is the interpolation coefficient times the higher prototype, plus
the lower prototype multiplied by the difference of 16 and the coefficient,
for each of the CELT bands.   
</t>

<t>
Because the computed target will sometimes be somewhat smaller than the
available space, the excess space is divided by the number of bands, and this amount
is added equally to each band. Any remaining space is added to the target one
sixteenth-bit at a time, starting from the first band. The new target now
matches the available space, in sixteenth-bits, exactly. 
</t>

<t>
The allocation target is separated into a portion used for fine energy
and a portion used for the Spherical Vector Quantizer (PVQ). The fine energy
quantizer operates in whole-bit steps. For each band the number of bits per 
channel used for fine energy is calculated by 50 minus the log2_frac(), with
1/16 bit precision, of the number of MDCT bins in the band. That result is multiplied
by the number of bins in the band and again by twice the number of                 
channels, and then the value is set to zero if it is less than zero. Added
to that result is 16 times the number of MDCT bins times the number of
channels,  and it is finally divided by 32 times the number of MDCT bins times the
number of channels. If the result times the number of channels is greater than than the
target divided by 16, the result is set to the target divided by the number of
channels divided by 16. Then if the value is greater than 7 it is reset to 7 because a
larger amount of fine energy resolution was determined not to be make an improvement in
perceived quality.  The resulting number of fine energy bits per channel is
then multiplied by the number of channels and then by 16, and subtracted
from the target allocation. This final target allocation is what is used for the
PVQ.
</t>

</section>

<section anchor="pitch-prediction" title="Pitch Prediction">
<t>
This section needs to be updated.
</t>

</section>

<section anchor="pvq" title="Spherical Vector Quantization">
<t>CELT uses a Pyramid Vector Quantization (PVQ) <xref target="PVQ"></xref>
codebook for quantizing the details of the spectrum in each band that have not
been predicted by the pitch predictor. The PVQ codebook consists of all sums
of K signed pulses in a vector of N samples, where two pulses at the same position
are required to have the same sign. Thus the codebook includes 
all integer codevectors y of N dimensions that satisfy sum(abs(y(j))) = K.
</t>

<t>
In bands where neither pitch nor folding is used, the PVQ is used to encode
the unit vector that results from the normalization in 
<xref target="normalization"></xref> directly. Given a PVQ codevector y, 
the unit vector X is obtained as X = y/||y||, where ||.|| denotes the 
L2 norm.
</t>

<section anchor="bits-pulses" title="Bits to Pulses">
<t>
Although the allocation is performed in 1/16 bit units, the quantization requires
an integer number of pulses K. To do this, the encoder searches for the value
of K that produces the number of bits that is the nearest to the allocated value
(rounding down if exactly half-way between two values), subject to not exceeding
the total number of bits available. The computation is performed in 1/16 of
bits using log2_frac() and ec_enc_tell(). The number of codebooks entries can
be computed as explained in <xref target="cwrs-encoding"></xref>. The difference
between the number of bits allocated and the number of bits used is accumulated to a
<spanx style="emph">balance</spanx> (initialised to zero) that helps adjusting the
allocation for the next bands. One third of the balance is subtracted from the
bit allocation of the next band to help achieving the target allocation. The only
exceptions are the band before the last and the last band, for which half the balance
and the whole balance are subtracted, respectively.
</t>
</section>

<section anchor="pvq-search" title="PVQ Search">

<t>
The search for the best codevector y is performed by alg_quant()
(<xref target="vq.c">vq.c</xref>). There are several possible approaches to the 
search with a tradeoff between quality and complexity. The method used in the reference
implementation computes an initial codeword y1 by projecting the residual signal 
R = X - p' onto the codebook pyramid of K-1 pulses:
</t>
<t>
y0 = round_towards_zero( (K-1) * R / sum(abs(R)))
</t>

<t>
Depending on N, K and the input data, the initial codeword y0 may contain from 
0 to K-1 non-zero values. All the remaining pulses, with the exception of the last one, 
are found iteratively with a greedy search that minimizes the normalized correlation
between y and R:
</t>

<t>
J = -R^T*y / ||y||
</t>

<t>
The search described above is considered to be a good trade-off between quality
and computational cost. However, there are other possible ways to search the PVQ
codebook and the implementors MAY use any other search methods.
</t>
</section>


<section anchor="cwrs-encoding" title="Index Encoding">
<t>
The best PVQ codeword is encoded as a uniformly-distributed integer value
by encode_pulses() (<xref target="cwrs.c">cwrs.c</xref>).
The codeword is converted to a unique index in the same way as specified in 
<xref target="PVQ"></xref>. The indexing is based on the calculation of V(N,K) (denoted N(L,K) in <xref target="PVQ"></xref>), which is the number of possible combinations of K pulses 
in N samples. The number of combinations can be computed recursively as 
V(N,K) = V(N+1,K) + V(N,K+1) + V(N+1,K+1), with V(N,0) = 1 and V(0,K) = 0, K != 0. 
There are many different ways to compute V(N,K), including pre-computed tables and direct
use of the recursive formulation. The reference implementation applies the recursive
formulation one line (or column) at a time to save on memory use,
along with an alternate,
univariate recurrence to initialise an arbitrary line, and direct
polynomial solutions for small N. All of these methods are
equivalent, and have different trade-offs in speed, memory usage, and
code size. Implementations MAY use any methods they like, as long as
they are equivalent to the mathematical definition.
</t>

<t>
The indexing computations are performed using 32-bit unsigned integers. For large codebooks,
32-bit integers are not sufficient. Instead of using 64-bit integers (or more), the encoding
is made slightly sub-optimal by splitting each band into two equal (or near-equal) vectors of
size (N+1)/2 and N/2, respectively. The number of pulses in the first half, K1, is first encoded as an
integer in the range [0,K]. Then, two codebooks are encoded with V((N+1)/2, K1) and V(N/2, K-K1). 
The split operation is performed recursively, in case one (or both) of the split vectors 
still requires more than 32 bits. For compatibility reasons, the handling of codebooks of more 
than 32 bits MUST be implemented with the splitting method, even if 64-bit arithmetic is available.
</t>
</section>

</section>


<section anchor="stereo" title="Stereo support">
<t>
When encoding a stereo stream, some parameters are shared across the left and right channels, while others are transmitted separately for each channel, or jointly encoded. Only one copy of the flags for the features, transients and pitch (pitch period and gains) are transmitted. The coarse and fine energy parameters are transmitted separately for each channel. Both the coarse energy and fine energy (including the remaining fine bits at the end of the stream) have the left and right bands interleaved in the stream, with the left band encoded first.
</t>

<t>
The main difference between mono and stereo coding is the PVQ coding of the normalized vectors. In stereo mode, a normalized mid-side (M-S) encoding is used. Let L and R be the normalized vector of a certain band for the left and right channels, respectively. The mid and side vectors are computed as M=L+R and S=L-R and no longer have unit norm.
</t>

<t>
From M and S, an angular parameter theta=2/pi*atan2(||S||, ||M||) is computed. The theta parameter is converted to a Q14 fixed-point parameter itheta, which is quantized on a scale from 0 to 1 with an interval of 2^-qb, where qb = (b-2*(N-1)*(40-log2_frac(N,4)))/(32*(N-1)), b is the number of bits allocated to the band, and log2_frac() is defined in <xref target="cwrs.c">cwrs.c</xref>. From here on, the value of itheta MUST be treated in a bit-exact manner since 
both the encoder and decoder rely on it to infer the bit allocation.
</t>
<t>
Let m=M/||M|| and s=S/||S||; m and s are separately encoded with the PVQ encoder described in <xref target="pvq"></xref>. The number of bits allocated to m and s depends on the value of itheta. The number of bits allocated to coding m is obtained by:
</t>

<t>
<list>
<t>imid = bitexact_cos(itheta);</t>
<t>iside = bitexact_cos(16384-itheta);</t>
<t>delta = (N-1)*(log2_frac(iside,6)-log2_frac(imid,6))>>2;</t>
<t>qalloc = log2_frac((1&lt;&lt;qb)+1,4);</t>
<t>mbits = (b-qalloc/2-delta)/2;</t>
</list>
</t>

<t>where bitexact_cos() is a fixed-point cosine approximation that MUST be bit-exact with the reference implementation
in <xref target="mathops.h">mathops.h</xref>. The spectral folding operation is performed independently for the mid and side vectors.</t>
</section>


<section anchor="synthesis" title="Synthesis">
<t>
After all the quantization is completed, the quantized energy is used along with the 
quantized normalized band data to resynthesize the MDCT spectrum. The inverse MDCT (<xref target="inverse-mdct"></xref>) and the weighted overlap-add are applied and the signal is stored in the <spanx style="emph">synthesis buffer</spanx> so it can be used for pitch prediction. 
The encoder MAY omit this step of the processing if it knows that it will not be using
the pitch predictor for the next few frames. If the de-emphasis filter (<xref target="inverse-mdct"></xref>) is applied to this resynthesized
signal, then the output will be the same (within numerical precision) as the decoder's output. 
</t>
</section>

<section anchor="vbr" title="Variable Bitrate (VBR)">
<t>
Each CELT frame can be encoded in a different number of octets, making it possible to vary the bitrate at will. This property can be used to implement source-controlled variable bitrate (VBR). Support for VBR is OPTIONAL for the encoder, but a decoder MUST be prepared to decode a stream that changes its bit-rate dynamically. The method used to vary the bit-rate in VBR mode is left to the implementor, as long as each frame can be decoded by the reference decoder.
</t>
</section>

</section>

<section anchor="CELT-decoder" title="CELT Decoder">

<t>
Like most audio codecs, the CELT decoder is less complex than the encoder, as can be
observed in the decoder block diagram in <xref target="decoder-diagram"></xref>. In
fact, most of the operations performed by the decoder are also performed by the
encoder.
</t>

<figure anchor="decoder-diagram">
<artwork>
<![CDATA[
                       +--+
                       |Q1|-------------+
                       +--+             |
                                        v
                       +--+  +-----+  +---+  +-----+
                       |Q3|->| Mix |->| * |->|IMDCT|-+-> output
                       +--+  +-----+  +---+  +-----+ |
                         ^      ^                    |
                         +------+                    |
                                |                    |
                       +--+   +-+-+                  |
                       |Q2|-->| * |                  |
                       +--+   +---+                  |
                                ^                    |
                                |                    |
                         +------+-----+              |
         +------------+  |Delay, MDCT,|              |
         |Pitch period|->|  Normalize |              |
         +------------+  +------------+              |
                                ^                    |
                                +--------------------+
]]>
</artwork>
<postamble>Block diagram of the CELT decoder</postamble>
</figure>

<t>
The decoder extracts information from the range-coded bit-stream in the same order
as it was encoded by the encoder. In some circumstances, it is 
possible for a decoded value to be out of range due to a very small amount of redundancy
in the encoding of large integers by the range coder.
In that case, the decoder should assume there has been an error in the coding, 
decoding, or transmission and SHOULD take measures to conceal the error and/or report
to the application that a problem has occurred.
</t>

<section anchor="range-decoder" title="Range Decoder">
<t>
The range decoder extracts the symbols and integers encoded using the range encoder in
<xref target="range-encoder"></xref>. The range decoder maintains an internal
state vector composed of the two-tuple (dif,rng), representing the
difference between the high end of the current range and the actual
coded value, and the size of the current range, respectively. Both
dif and rng are 32-bit unsigned integer values. rng is initialized to
2^7. dif is initialized to rng minus the top 7 bits of the first
input octet. Then the range is immediately normalized, using the
procedure described in the following section.
</t>

<section anchor="decoding-symbols" title="Decoding Symbols">
<t>
   Decoding symbols is a two-step process. The first step determines
   a value fs that lies within the range of some symbol in the current
   context. The second step updates the range decoder state with the
   three-tuple (fl,fh,ft) corresponding to that symbol, as defined in
   <xref target="encoding-symbols"></xref>.
</t>
<t>
   The first step is implemented by ec_decode() 
   (<xref target="rangedec.c">rangedec.c</xref>), 
   and computes fs = ft-min((dif-1)/(rng/ft)+1,ft), where ft is
   the sum of the frequency counts in the current context, as described
   in <xref target="encoding-symbols"></xref>. The divisions here are exact integer division. 
</t>
<t>
   In the reference implementation, a special version of ec_decode()
   called ec_decode_bin() (<xref target="rangeenc.c">rangeenc.c</xref>) is defined using
   the parameter ftb instead of ft. It is mathematically equivalent to
   calling ec_decode() with ft = (1&lt;&lt;ftb), but avoids one of the
   divisions.
</t>
<t>
   The decoder then identifies the symbol in the current context
   corresponding to fs; i.e., the one whose three-tuple (fl,fh,ft)
   satisfies fl &lt;= fs &lt; fh. This tuple is used to update the decoder
   state according to dif = dif - (rng/ft)*(ft-fh), and if fl is greater
   than zero, rng = (rng/ft)*(fh-fl), or otherwise rng = rng - (rng/ft)*(ft-fh). After this update, the range is normalized.
</t>
<t>
   To normalize the range, the following process is repeated until
   rng > 2^23. First, rng is set to (rng&lt;8)&amp;0xFFFFFFFF. Then the next
   8 bits of input are read into sym, using the remaining bit from the
   previous input octet as the high bit of sym, and the top 7 bits of the
   next octet for the remaining bits of sym. If no more input octets
   remain, zero bits are used instead. Then, dif is set to
   (dif&lt;&lt;8)-sym&amp;0xFFFFFFFF (i.e., using wrap-around if the subtraction
   overflows a 32-bit register). Finally, if dif is larger than 2^31,
   dif is then set to dif - 2^31. This process is carried out by
   ec_dec_normalize() (<xref target="rangedec.c">rangedec.c</xref>).
</t>
</section>

<section anchor="decoding-ints" title="Decoding Uniformly Distributed Integers">
<t>
   Functions ec_dec_uint() or ec_dec_bits() are based on ec_decode() and
   decode one of N equiprobable symbols, each with a frequency of 1,
   where N may be as large as 2^32-1. Because ec_decode() is limited to
   a total frequency of 2^16-1, this is done by decoding a series of
   symbols in smaller contexts.
</t>
<t>
   ec_dec_bits() (<xref target="entdec.c">entdec.c</xref>) is defined, like
   ec_decode_bin(), to take a single parameter ftb, with ftb &lt; 32.
   and ftb &lt; 32, and produces an ftb-bit decoded integer value, t,
   initialized to zero. While ftb is greater than 8, it decodes the next
   8 most significant bits of the integer, s = ec_decode_bin(8), updates
   the decoder state with the 3-tuple (s,s+1,256), adds those bits to
   the current value of t, t = t&lt;&lt;8 | s, and subtracts 8 from ftb. Then
   it decodes the remaining bits of the integer, s = ec_decode_bin(ftb),
   updates the decoder state with the 3 tuple (s,s+1,1&lt;&lt;ftb), and adds
   those bits to the final values of t, t = t&lt;&lt;ftb | s.
</t>
<t>
   ec_dec_uint() (<xref target="entdec.c">entdec.c</xref>) takes a single parameter,
   ft, which is not necessarily a power of two, and returns an integer,
   t, with a value between 0 and ft-1, inclusive, which is initialized to zero. Let
   ftb be the location of the highest 1 bit in the two's-complement
   representation of (ft-1), or -1 if no bits are set. If ftb>8, then
   the top 8 bits of t are decoded using t = ec_decode((ft-1>>ftb-8)+1),
   the decoder state is updated with the three-tuple
   (s,s+1,(ft-1>>ftb-8)+1), and the remaining bits are decoded with
   t = t&lt;&lt;ftb-8|ec_dec_bits(ftb-8). If, at this point, t >= ft, then
   the current frame is corrupt, and decoding should stop. If the
   original value of ftb was not greater than 8, then t is decoded with
   t = ec_decode(ft), and the decoder state is updated with the
   three-tuple (t,t+1,ft).
</t>
</section>

<section anchor="decoder-tell" title="Current Bit Usage">
<t>
   The bit allocation routines in CELT need to be able to determine a
   conservative upper bound on the number of bits that have been used
   to decode from the current frame thus far. This drives allocation
   decisions which must match those made in the encoder. This is
   computed in the reference implementation to fractional bit precision
   by the function ec_dec_tell() (<xref target="rangedec.c">rangedec.c</xref>). Like all
   operations in the range decoder, it must be implemented in a
   bit-exact manner, and must produce exactly the same value returned by
   ec_enc_tell() after encoding the same symbols.
</t>
</section>

</section>

<section anchor="energy-decoding" title="Energy Envelope Decoding">
<t>
The energy of each band is extracted from the bit-stream in two steps according
to the same coarse-fine strategy used in the encoder. First, the coarse energy is
decoded in unquant_coarse_energy() (<xref target="quant_bands.c">quant_bands.c</xref>)
based on the probability of the Laplace model used by the encoder.
</t>

<t>
After the coarse energy is decoded, the same allocation function as used in the
encoder is called (<xref target="allocation"></xref>). This determines the number of
bits to decode for the fine energy quantization. The decoding of the fine energy bits
is performed by unquant_fine_energy() (<xref target="quant_bands.c">quant_bands.c</xref>).
Finally, like the encoder, the remaining bits in the stream (that would otherwise go unused)
are decoded using unquant_energy_finalise() (<xref target="quant_bands.c">quant_bands.c</xref>).
</t>
</section>

<section anchor="pitch-decoding" title="Pitch prediction decoding">
<t>
If the pitch bit is set, then the pitch period is extracted from the bit-stream. The pitch
gain bits are extracted within the PVQ decoding as encoded by the encoder. When the folding
bit is set, the folding prediction is computed in exactly the same way as the encoder, 
with the same gain, by the function intra_fold() (<xref target="vq.c">vq.c</xref>).
</t>

</section>

<section anchor="PVQ-decoder" title="Spherical VQ Decoder">
<t>
In order to correctly decode the PVQ codewords, the decoder must perform exactly the same
bits to pulses conversion as the encoder (see <xref target="bits-pulses"></xref>).
</t>

<section anchor="cwrs-decoder" title="Index Decoding">
<t>
The decoding of the codeword from the index is performed as specified in 
<xref target="PVQ"></xref>, as implemented in function
decode_pulses() (<xref target="cwrs.c">cwrs.c</xref>). 
</t>
</section>

<section anchor="normalised-decoding" title="Normalised Vector Decoding">
<t>
The spherical codebook is decoded by alg_unquant() (<xref target="vq.c">vq.c</xref>).
The index of the PVQ entry is obtained from the range coder and converted to 
a pulse vector by decode_pulses() (<xref target="cwrs.c">cwrs.c</xref>).
</t>

<t>The decoded normalized vector for each band is equal to</t>
<t>X' = y/||y||,</t>

<t>
This operation is implemented in mix_pitch_and_residual() (<xref target="vq.c">vq.c</xref>), 
which is the same function as used in the encoder.
</t>
</section>


</section>

<section anchor="denormalization" title="Denormalization">
<t>
Just like each band was normalized in the encoder, the last step of the decoder before
the inverse MDCT is to denormalize the bands. Each decoded normalized band is
multiplied by the square root of the decoded energy. This is done by denormalise_bands()
(<xref target="bands.c">bands.c</xref>).
</t>
</section>

<section anchor="inverse-mdct" title="Inverse MDCT">
<t>The inverse MDCT implementation has no special characteristics. The
input is N frequency-domain samples and the output is 2*N time-domain 
samples, while scaling by 1/2. The output is windowed using the same
<spanx style="emph">low-overlap</spanx> window 
as the encoder. The IMDCT and windowing are performed by mdct_backward
(<xref target="mdct.c">mdct.c</xref>). If a time-domain pre-emphasis 
window was applied in the encoder, the (inverse) time-domain de-emphasis window
is applied on the IMDCT result. After the overlap-add process, 
the signal is de-emphasized using the inverse of the pre-emphasis filter 
used in the encoder: 1/A(z)=1/(1-alpha_p*z^-1).
</t>

</section>

<section anchor="Packet Loss Concealment" title="Packet Loss Concealment (PLC)">
<t>
Packet loss concealment (PLC) is an optional decoder-side feature which 
SHOULD be included when transmitting over an unreliable channel. Because 
PLC is not part of the bit-stream, there are several possible ways to 
implement PLC with different complexity/quality trade-offs. The PLC in
the reference implementation finds a periodicity in the decoded
signal and repeats the windowed waveform using the pitch offset. The windowed
waveform is overlapped in such a way as to preserve the time-domain aliasing
cancellation with the previous frame and the next frame. This is implemented 
in celt_decode_lost() (<xref target="celt.c">mdct.c</xref>).
</t>
</section>

</section>



<section anchor="Security Considerations" title="Security Considerations">

<t>
A potential denial-of-service threat exists for data encodings using
compression techniques that have non-uniform receiver-end
computational load.  The attacker can inject pathological datagrams
into the stream which are complex to decode and cause the receiver to
become overloaded.  However, this encoding does not exhibit any
significant non-uniformity.
</t>

<t>
With the exception of the first four bits, the bit-stream produced by
CELT for an unknown audio stream is not easily predictable, due to the
use of entropy coding. This should make CELT less vulnerable to attacks
based on plaintext guessing when encryption is used. Also, since almost
all possible bit combinations can be interpreted as a valid bit-stream,
it is likely more difficult to determine from the decrypted bit-stream
whether a guessed decryption key is valid.
</t>

<t>
When operating CELT in variable-bitrate (VBR) mode, some of the
properties described above no longer hold. More specifically, the size
of the packet leaks a very small, but non-zero, amount of information
about both the original signal and the bit-stream plaintext.
</t>
</section> 


<section title="IANA Considerations ">
<t>
This document has no actions for IANA.
</t>
</section>


<section anchor="Acknowledgments" title="Acknowledgments">

<t>
The authors would also like to thank the CELT users who contributed patches, bug reports, feature requests, suggestions or comments.
</t>
</section> 

</middle>

<back>

<references title="Normative References">

<reference anchor="rfc2119">
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels </title>
<author initials="S." surname="Bradner" fullname="Scott Bradner"><organization/></author>
</front>
<seriesInfo name="RFC" value="2119" />
</reference> 

<reference anchor="rfc3550">
<front>
<title>RTP: A Transport Protocol for real-time applications</title>
<author initials="H." surname="Schulzrinne" fullname=""><organization/></author>
<author initials="S." surname="Casner" fullname=""><organization/></author>
<author initials="R." surname="Frederick" fullname=""><organization/></author>
<author initials="V." surname="Jacobson" fullname=""><organization/></author>
</front>
<seriesInfo name="RFC" value="3550" />
</reference> 


</references> 

<references title="Informative References">

<reference anchor="celt-tasl">
<front>
<title>A High-Quality Speech and Audio Codec With Less Than 10 ms delay</title>
<author initials="JM" surname="Valin" fullname="Jean-Marc Valin"><organization/></author>
<author initials="T. B." surname="Terriberry" fullname="Timothy Terriberry"><organization/></author>
<author initials="C." surname="Montgomery" fullname="Christopher Montgomery"><organization/></author>
<author initials="G." surname="Maxwell" fullname="Gregory Maxwell"><organization/></author>
</front>
<seriesInfo name="To appear in IEEE Transactions on Audio, Speech and Language Processing" value="2009" />
</reference> 

<reference anchor="celt-eusipco">
<front>
<title>A Full-Bandwidth Audio Codec with Low Complexity and Very Low Delay</title>
<author initials="JM" surname="Valin" fullname="Jean-Marc Valin"><organization/></author>
<author initials="T. B." surname="Terriberry" fullname="Timothy Terriberry"><organization/></author>
<author initials="G." surname="Maxwell" fullname="Gregory Maxwell"><organization/></author>
</front>
<seriesInfo name="Accepted for EUSIPCO" value="2009" />
</reference> 

<reference anchor="celt-website">
<front>
<title>The CELT ultra-low delay audio codec</title>
<author><organization/></author>
</front>
<seriesInfo name="CELT website" value="http://www.celt-codec.org/" />
</reference> 

<reference anchor="mdct">
<front>
<title>Modified Discrete Cosine Transform</title>
<author><organization/></author>
</front>
<seriesInfo name="MDCT" value="http://en.wikipedia.org/wiki/Modified_discrete_cosine_transform" />
</reference> 

<reference anchor="range-coding">
<front>
<title>Range encoding: An algorithm for removing redundancy from a digitised message</title>
<author initials="G." surname="Nigel" fullname=""><organization/></author>
<author initials="N." surname="Martin" fullname=""><organization/></author>
<date year="1979" />
</front>
<seriesInfo name="Proc. Institution of Electronic and Radio Engineers International Conference on Video and Data Recording" value="" />
</reference> 

<reference anchor="coding-thesis">
<front>
<title>Source coding algorithms for fast data compression</title>
<author initials="R." surname="Pasco" fullname=""><organization/></author>
<date month="May" year="1976" />
</front>
<seriesInfo name="Ph.D. thesis" value="Dept. of Electrical Engineering, Stanford University" />
</reference>

<reference anchor="PVQ">
<front>
<title>A Pyramid Vector Quantizer</title>
<author initials="T." surname="Fischer" fullname=""><organization/></author>
<date month="July" year="1986" />
</front>
<seriesInfo name="IEEE Trans. on Information Theory, Vol. 32" value="pp. 568-583" />
</reference> 

</references>

<section anchor="ref-implementation" title="Reference Implementation">

<t>This appendix contains the complete source code for a floating-point
reference implementation of the CELT codec written in C. This
implementation is derived from version 0.8.1 of the implementation available on the 
<xref target="celt-website"></xref>, which can be compiled for 
either floating-point or fixed-point architectures.
</t>

<t>The implementation can be compiled with either a C89 or a C99
compiler. It is reasonably optimized for most platforms such that
only architecture-specific optimizations are likely to be useful.
The FFT used is a slightly modified version of the KISS-FFT package,
but it is easy to substitute any other FFT library.
</t>

<t>
The testcelt executable can be used to test the encoding and decoding
process:
<list style="empty">
<t><![CDATA[
testcelt <rate> <channels> <frame size> <octets per packet>
         [<complexity> [packet loss rate]] <input> <output>
]]></t>
</list>
where "rate" is the sampling rate in Hz, "channels" is the number of
channels (1 or 2), "frame size" is the number of samples in a frame 
(64 to 1024) and "octets per packet" is the number of octets desired for each
compressed frame. The input and output files are assumed to be a 16-bit
PCM file in the machine native endianness. The optional "complexity" argument
can select the quality vs complexity tradeoff (0-10) and the "packet loss rate"
argument simulates random packet loss (argument is in tenths or a percent).
</t>

<?rfc include="xml_source/Makefile"?>
<?rfc include="xml_source/testcelt.c"?>
<?rfc include="xml_source/celt.h"?>
<?rfc include="xml_source/celt.c"?>
<?rfc include="xml_source/modes.h"?>
<?rfc include="xml_source/modes.c"?>
<?rfc include="xml_source/bands.h"?>
<?rfc include="xml_source/bands.c"?>
<?rfc include="xml_source/cwrs.h"?>
<?rfc include="xml_source/cwrs.c"?>
<?rfc include="xml_source/vq.h"?>
<?rfc include="xml_source/vq.c"?>
<?rfc include="xml_source/pitch.h"?>
<?rfc include="xml_source/pitch.c"?>
<?rfc include="xml_source/rate.h"?>
<?rfc include="xml_source/rate.c"?>
<?rfc include="xml_source/plc.h"?>
<?rfc include="xml_source/plc.c"?>
<?rfc include="xml_source/mdct.h"?>
<?rfc include="xml_source/mdct.c"?>
<?rfc include="xml_source/ecintrin.h"?>
<?rfc include="xml_source/entcode.h"?>
<?rfc include="xml_source/entcode.c"?>
<?rfc include="xml_source/entenc.h"?>
<?rfc include="xml_source/entenc.c"?>
<?rfc include="xml_source/entdec.h"?>
<?rfc include="xml_source/entdec.c"?>
<?rfc include="xml_source/mfrngcod.h"?>
<?rfc include="xml_source/rangeenc.c"?>
<?rfc include="xml_source/rangedec.c"?>
<?rfc include="xml_source/laplace.h"?>
<?rfc include="xml_source/laplace.c"?>
<?rfc include="xml_source/quant_bands.h"?>
<?rfc include="xml_source/quant_bands.c"?>
<?rfc include="xml_source/arch.h"?>
<?rfc include="xml_source/mathops.h"?>
<?rfc include="xml_source/os_support.h"?>
<?rfc include="xml_source/stack_alloc.h"?>
<?rfc include="xml_source/celt_types.h"?>
<?rfc include="xml_source/_kiss_fft_guts.h"?>
<?rfc include="xml_source/kiss_fft.h"?>
<?rfc include="xml_source/kiss_fft.c"?>
<?rfc include="xml_source/kiss_fftr.h"?>
<?rfc include="xml_source/kiss_fftr.c"?>
<?rfc include="xml_source/kfft_single.h"?>
<?rfc include="xml_source/kfft_double.h"?>
<?rfc include="xml_source/config.h"?>

</section>


</back>

</rfc>
